---
title: 自己手写一个 promise（转）
date: 2018-04-02 10:46:38
tags:
- javascript
- promise
categories:
- 转载
description: 手写 promise
---

[原文链接](https://juejin.im/post/5ab20c58f265da23a228fe0f)

# 初始版本

```javascript
function Promise(executor){ //executor是一个执行器（函数）

  let _this = this // 先缓存this以免后面指针混乱

  _this.status = 'pending' // 默认状态为等待态
  _this.value = undefined // 成功时要传递给成功回调的数据，默认undefined
  _this.reason = undefined // 失败时要传递给失败回调的原因，默认undefined

  function resolve(value) { // 内置一个resolve方法，接收成功状态数据
    // 上面说了，只有pending可以转为其他状态，所以这里要判断一下
    if (_this.status === 'pending') {
      _this.status = 'resolved' // 当调用resolve时要将状态改为成功态
      _this.value = value // 保存成功时传进来的数据
    }
  }

  function reject(reason) { // 内置一个reject方法，失败状态时接收原因
    if (_this.status === 'pending') { // 和resolve同理
      _this.status = 'rejected' // 转为失败态
      _this.reason = reason // 保存失败原因
    }
  }
  executor(resolve, reject) // 执行执行器函数，并将两个方法传入
}

// then方法接收两个参数，分别是成功和失败的回调，这里我们命名为onFulfilled和onRjected
Promise.prototype.then = function(onFulfilled, onRjected){
  let _this = this; // 依然缓存this
  if(_this.status === 'resolved'){ // 判断当前Promise的状态
    onFulfilled(_this.value) // 如果是成功态，当然是要执行用户传递的成功回调，并把数据传进去
  }
  if(_this.status === 'rejected'){ // 同理
    onRjected(_this.reason)
  }
}

module.exports = Promise // 导出模块，否则别的文件没法使用
```

但是回调函数是立即执行的，无法异步操作：

```javascript
let p = new Promise(function(resolve, reject){

  setTimeout(function(){

    resolve(100)

  }, 1000)

})

p.then(function(data){

  console.log('成功', data)

},function(err){

  console.log('失败', err)

})
```

原因是我们在 `then` 函数中只对成功态和失败态进行了判断，而实例被 `new` 时，执行器中的代码会立即执行，但 `setTimeout` 中的代码将稍后执行，也就是说，`then` 方法执行时，`Promise` 的状态没有被改变依然是 `pending` 态，所以我们要对 `pending` 态也做判断，而由于代码可能是异步的，那么我们就要想办法把回调函数进行缓存，并且，`then` 方法是可以多次使用的，所以要能存多个回调，那么这里我们用一个数组。

# 实现异步
在实例上挂两个参数

```javascript
_this.onResolvedCallbacks = []; // 存放then成功的回调
_this.onRejectedCallbacks = []; // 存放then失败的回调
```

`then` 方法加一个 `pending` 的判断

```javascript
// 新增分支判断
if(_this.status === 'pending'){
  // 每一次then时，如果是等待态，就把回调函数push进数组中，什么时候改变状态什么时候再执行
  _this.onResolvedCallbacks.push(function(){ // 这里用一个函数包起来，是为了后面加入新的逻辑进去
    onFulfilled(_this.value)
  })

  _this.onRejectedCallbacks.push(function(){ // 同理
    onRjected(_this.reason)
  })
}
```

下一步要分别在 `resolve` 和 `reject` 方法里加入执行数组中存放的函数的方法，修改一下上面的 `resolve` 和 `reject` 方法

```javascript
function resolve(value) {
  if (_this.status === 'pending') {
    _this.status = 'resolved'
    _this.value = value
    _this.onResolvedCallbacks.forEach(function(fn){ // 当成功的函数被调用时，之前缓存的回调函数会被一一调用
      fn()
    })
  }
}

function reject(reason) {
  if (_this.status === 'pending') {
    _this.status = 'rejected'
    _this.reason = reason
    _this.onRejectedCallbacks.forEach(function(fn){// 当失败的函数被调用时，之前缓存的回调函数会被一一调用
      fn()
    })
  }
}
```

现在可以执行异步任务了，也可以多次 `then` 了

```javascript
let p = new Promise(function(resolve, reject){
  setTimeout(function(){
    resolve(100)
  }, 1000)
})

p.then(function(data){
  console.log('成功', data)
},function(err){
  console.log('失败', err)
})

p.then(function(data) {
  console.log('成功2', data)
})
```

# 处理错误
上面的代码虽然能用，但经不起考验，真正的 `Promise` 如果在实例中抛出错误，应该走 `reject`

```javascript
new Promise(function(resolve, reject){
  throw new Error('错误')
}).then(function(){

},function(err){
  console.log('错误:', err)
})
// 错误: Error: 错误
```

我们实现一下，思路很简单，在执行器执行时进行 `try catch`

```javascript
try {
  executor(resolve, reject) // 执行执行器函数，并将两个方法传入
} catch (e) {
  reject(e)
}
```

# 实现 `then` 的链式调用
上面说过了，`then` 可以链式调用，也是这一点让 `Promise` 十分好用，当然这部分源码也比较复杂。
我们知道 `jquery` 实现链式调用是 `return` 了一个 `this`，但 `Promise` 不行，为什么不行？
正宗的 `Promise` 是这样的套路：

```javascript
let p1 = new Promise(function(resolve, reject){
  resolve()
})

let p2 = p1.then(function(data){ //这是p1的成功回调，此时p1是成功态
  throw new Error('错误') // 如果这里抛出错误，p2应是失败态
})

p2.then(function(){

},function(err){
  console.log(err)
})

// Error: 错误
```

如果返回的是 `this`，那么 `p2` 跟 `p1` 相同，固状态也相同，但上面说了，`Promise` 的成功态和失败态不能相互转换，那就不会得到 `p1` 成功而 `p2` 失败的效果，而实际上是可能发生这种情况的。

所以 `Promise` 的 `then` 方法实现链式调用的原理是：**返回一个新的 `Promise`**

在 `then` 方法中先定义一个新的 `Promise`，取名为 `promise2`（官方规定的），然后在三种状态下分别用 `promise2` 包装一下，在调用`onFulfilled` 时用一个变量 x（规定的）接收返回值，`try catch` 一下代码，没错就调 `resolve` 传入x，有错就调 `reject` 传入错误，最后再把 `promise2` 给 `return` 出去，就可以进行链式调用了，，，，但是！

```javascript
// 改动then
let promise2;
if (_this.status === 'resolved') {
  promise2 = new Promise(function (resolve, reject) {
    // 可以凑合用，但是是有很多问题的
    try {
      let x = onFulfilled(_this.value)
      resolve(x)
    } catch (e) {
      reject(e)
    }
  })
}

if (_this.status === 'rejected') {
  promise2 = new Promise(function (resolve, reject) {
    // 可以凑合用，但是是有很多问题的
    try {
      let x = onRjected(_this.reason)
      resolve(x)
    } catch (e) {
      reject(e)
    }
  })
}

if(_this.status === 'pending'){
  promise2 = new Promise(function (resolve, reject) {
    _this.onResolvedCallbacks.push(function(){
      // 可以凑合用，但是是有很多问题的
      try {
        let x = onFulfilled(_this.value)
        resolve(x)
      } catch (e) {
        reject(e)
      }
    })

    _this.onRejectedCallbacks.push(function(){
      // 可以凑合用，但是是有很多问题的
      try {
        let x = onRjected(_this.reason)
        resolve(x)
      } catch (e) {
        reject(e)
      }
    })
  })
}
return promise2
```

这里我先解释一下x的作用再说为什么不行，x 是用来接收上一次then的返回值，比如这样

```javascript
let p = new Promise(function(resolve, reject){
  resolve('hello')
})

p.then(function(data){
  return data + ' handled' // 这里返回一个值
}, function(){

}).then(function(data){
  console.log(data) // 这里会接收到 hello handled
}, function(){
})
// 以上代码中第一次then的返回值就是源码内第一次调用onResolve的返回值，可以用一个x来接收
```

接下来说问题，上面这样看起来是符合逻辑的，并且也确实可以链式调用并接受到，但我们在写库，库就要经得起考验，把容错性提到最高，要接受使用者各种新（cao）奇（dan）操作，所谓有容nai大。可能性如下：

1. 前一次then返回一个普通值，字符串数组对象这些东西，都没问题，只需传给下一个 then，刚才的方法就够用。
2. 前一次then返回的是一个 Promise，是正常的操作，也是Promise提供的语法糖，我们要想办法判断到底返回的是啥。
3. 前一次then返回的是一个 Promise，其中有异步操作，也是理所当然的，那我们就要等待他的状态改变，再进行下面的处理。
4. 前一次then返回的是自己本身这个 Promise

```javascript
var p1 = p.then(function(){// 这里得用var，let由于作用域的原因会报错undefined
  return p1
})
```

5. 前一次 then 返回的是一个别人自己随便写的 Promise，这个 Promise 可能是个有 then 的普通对象，比如{then:'哈哈哈'}，也有可能在then里故意抛错（这种蛋疼的操作我们也要考虑进去）。比如他这样写

```javascript
let promise = {}

Object.defineProperty(promise,'then',{
  value: function(){
    throw new Error('报错气死你')
  }
})

// 如果返回这东西，我们再去调then方法就肯定会报错了
```

6. 调 resolve 的时候再传一个 Promise 下去，我们还得处理这个 Promise。

```javascript
p.then(function(data) {
  return new Promise(function(resolve, reject) {
    resolve(new Promise(function(resolve,reject){
      resolve(1111)
    }))
  })
})
```

7. 可能既调 resolve 又调 reject，得忽略后一个。
8. 光 then，里面啥也不写。

好了咱们调整心情继续撸，其实这一系列的问题，很多都是相关的，只要根据规范，都可以顺利解决，接上面的代码，先干三件事：

